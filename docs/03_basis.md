# 基础知识

## 变量与可变性

- 使用`let`关键字声明变量
- 默认情况下，变量是不可变的（immutable）
- 声明变量的时候加入`mut`关键字就可以使变量可变

### 常量

常量(constant)，常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别：
- 声明常量使用`const`关键字，它的**类型必须被标注**
- 不可以使用`mut`，常量永远都是不可变的
- 常量可以在任何作用域内进行声明，包括全局作用域
- 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命名规范：Rust里常量使用全大写字母，每个单词之间用下划线分开，例如：`MAX_POINTS`

### Shadowing（隐藏）

可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量

```rust
let x = 5;
let x = x + 1;
// 这两个x是不同的变量，第二个把第一个隐藏了
```

shadow和把变量标记为`mut`是不一样的：
- 如果不使用`let`关键字，那么重新给非`mut`的变量赋值会导致编译时错误
- 而使用`let`声明的同名新变量，也是不可变的
- 使用`let`声明的同名新变量，它的类型可以与之前不同

## 数据类型

- 标量和复合类型
- Rust是静态编译语，在编译时必须知道所有变量的类型
    - 基于使用的值，编译器通常能够推断出它的具体类型
    - 但如果可能的类型比较多，就必须添加类型的标注，否则编译会报错
        - 例如把`String`转为整数的`parse`方法
        - `let guess: u32 = "42".parse().expect("Not a number!");`

### 标量

#### 整数类型

- 整数类型没有小数部分
- 例如`u32`就是一个无符号的整数类型，占据32位的空间
- 无符号整数类型以`u`开头 unsigned
- 有符号整数类型以`i`开头 integer
- 范围
    - 有符号 $-2^{n-1} 到 2^{n-1}-1$
    - 无符号 $0 到 2^n-1$

Length  | Signed    | Unsigned
--------|-----------|----------
8-bit   | i8        | u8
16-bit  | i16       | u16
32-bit  | i32       | u32
128-bit | i64       | u64
arch    | isize     | usize

- `arch` 为 architecture 表示 系统架构
    - 其大小由系统构架决定，64位计算机，就是64位的
    - 其使用场景是对某种集合进行索引操作

##### 整数的字面值

Number literals | Example
----------------|--------------
Decimal 十进制  | 98_222
Hex 十六进制    | 0xff
Octal 八进制    | 0o77
Binary 二进制   | ob 1111_0000
Byte (u8 only)  | b'A'

可使用`_`增强可读性

- 除了byte类型外，所有的数值字面值都允许使用类型后缀。
    - 例如`57u8` u8 类型
- 如果你不太清楚应该使用那种类型，可以使用Rust相应的默认类型：
- 整数的默认类型就是i32：
    - 总体上来说速度很快，即使在64位系统中

##### 整数溢出

例如：u8的范围是0-255，如果你把一个u8变量的值设为256，那么：
- 调试模式下编译：Rust会检查整数溢出，如果发生溢出，程序在运行时就会panic
- 发布模式下`--release`编译：Rust不会检查可能导致panic的整数溢出。
    - 如果溢出发生：Rust会执行“环绕”操作
        - 256变成0，257变成1.
    - 但程序不会panic

#### 浮点类型

- Rust有两种基础的浮点类型，也就是含有小数部分的类型
    - `f32`，32位，单精度
    - `f64`，64位，双精度
- Rust的浮点类型使用了IEEE-754标准来表述
- `f64`是默认类型，因为在现代CPU上`f64`和`f32`的速度差不多，而且精度更高。

#### 数值操作

加减乘除余等

```rust
let sum = 5 + 10;

let difference = 95.5 - 4.3;

let product = 4 * 30;

let quotient = 56.7 / 32.2;

let remainder = 54 % 5;
```

#### 布尔类型

- 符号 `bool`，占一个字节
- `ture` 或 `false`

#### 字符类型

- Rust语言中`char`类型被用来描述语言中最基础的单个字符。
- 字符类型的字面值使用单引号`'`
- 占用4字节大小
- 是Unicode标量值，可以表示比ASCII多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji表情等。

### 复合类型

- 复合类型可以将多个值放在一个类型里
- Rust提供了两种基础的复合类型：元组（Tuple）、数组

#### 元组

- Tuple可以将多个类型的多个值放在一个类型里
- Tuple的长度是固定的：一旦声明就无法改变

创建元组：
- 在小括号内，将值用逗号分开：`(123, "string", 13.5)`
- 每个位置都对应一个类型，元组中各元素**类型不必相同**

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);    // 可以指明类型

println!("{}, {}, {}", tup.0, tup.1, tup.2);    // 500, 6.4, 1
```

获取元组的元素值：
- 使用模式匹配来解构一个元组来获取元素值（destructure）

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup; // destructure

println!("{}, {}, {}", x, y, z);    // 500, 6.4, 1
```

访问：`变量.索引`

#### 数组

- 数组也可以将多个值放在一个类型里
- 数组中每个元素的类型必须相同
- 数组的长度是固定的

创建数组：
- 在中括号内，将值用逗号分开：`[123, 124332, 13]`

数组的用处
- 如果想让你的数据存放在stack（栈）上而不是heap（堆）上，或者想保证有固定数量的元素，这时使用数组更有好处
- 数组没有Vector灵活（以后再讲）。（应该与C#的 `List<T>` 相似）
    - Vector和数组类似，它由标准库提供
    - Vector的长度可以改变
    - 如果你不确定应该用数组还是Vector，那么估计你应该用vectoro

数组的类型
- `[类型; 长度]`
    - 例：`let a: [i32; 5] = [1, 2, 3, 4, 5];`

另一种声明数组的方法
- 如果数组的每个元素值都相同，那么可以在：
    - 在中括号里指定初始值
    - 然后是一个`;`
    - 最后是数组的长度
- 例如：`let a = [3; 5];`它就相当于：`let a = [3, 3, 3, 3, 3];`

访问：
- 数组是Stack上分配的单个块的内存
- 可以使用索引来访问数组的元素，零是第一个
    - `a[0]`
- 如果访问索引超出了数组的范围，那么
    - 编译可能会通过（在复杂的情况下，可能不会）
    - 运行会报错
- Rust 不允许其继续访问相应地址的内存
    - 数组在内存内是连续存放的

```rust
// this operation will panic at runtime
let a = [5; 5];
print!("{}", a[5]);
//           ^^^^ index out of bounds: the length is 5 but the index is 5
let index = 6;
print!("{}", a[index]); // 编译也会报错

let indexes = [5, 6, 7, 8];
print!("{}", a[indexes[2]]); // 编译不会会报错
```

## 函数

- 声明函数使用`fn`关键字
- 依照惯例，针对函数和变量名，Rust使用snakecase命名规范：
    - 所有的字母都是小写的，单词之间使用下划线分开
    - `fn post_log() { }`

### 参数

- parameters 形参
- arguments 实参
- 函数类型里，必须声明形参的类型

### 函数体中的语句与表达式
- 函数体由一系列语句`statement`组成，可选的由一个表达式`expression`结束
- Rust是一个基于表达式的语言
- 语句是执行一些动作的指令
- 表达式会计算产生一个值
- 函数的定义也是语句
- 语句不返回值，所以不可以使用`let`将一个语句赋值给一个变量

```rust
fn main() {
    let x = 5;  // 语句

    let y = {   // 大括号是一个块
        let x = 1;
        x + 3   // 这里是表达式，不是语句，相当于是块的返回值，是块这个表达式的值
    }

    println!("y = {}", y);  // y = 4
}
```

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 1;
        x + 3;  // 加上了分号，变成了语句。
    }   // 整个块的返回值 为 空的元组 ()

    println!("y = {}", y);  // 空元组无法打印
}
```

### 函数的返回值
- 在`->`符号后边声明函数返回值的类型，但是不可以为返回值命名
- **在Rust里面，返回值就是函数体里面最后一个表达式的值**
- 若想提前返回，需使用`return`关键字，并指定一个值
    - 大多数函数都是默认使用最后一个表达式最为返回值

```
fn five() -> i32 {
    5   // 一定不要有分号
}

fn main() {
    let x = five();

    println!("x = {}", x);  // x = 5
}
```

## 控制流

### if表达式

- if表达式允许您根据条件来执行不同的代码分支
    - 这个条件必须是`bool`类型
- if表达式中，与条件相关联的代码块就叫做分支(arm)
- 可选的，在后边可以加上一个else表达式

```rust
if <expression> {
    
} else if <expression2> {

} else {

}
```

! 如果使用了多于一个else if，最好使用`match`重构代码

由于if为表达式，而不是语句，所以可以将它放在`let`语句中等号的右侧

```rust
let condition = true;
let number = if condition { 5 } else { 6 }; // if else表达式的结果必须返回相同的类型
let number = if condition { 5 } else { "6" }; // 报错
```

### 循环

#### loop 表达式

- 无限循环，直到`break`
- `break`后为整个loop表达式的返回值

```rust
let mut counter = 0;

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;  // break后为整个loop表达式的返回值
    }
};

println!("result = {}", result);    // result = 20
```

#### while

- 循环之前判断一次

```rust
let mut number = 3;

while number != 0 {
    println!("{}！", number);
    number -= 1;
}

println!("点火！");
// 3！
// 2！
// 1！
// 点火！
```

#### for 循环遍历集合

- `for i in <可遍历的> {}`

```rust
let a = [10, 20, 30, 40, 50];

for element in a.iter() {
    // element 的类型为 &i32 是引用
    println!("值为 {}", element);
}
```

#### Range


- 标准库提供
- `开始..结尾` 指定一个开始数字和一个结束数字，Range可以生成它们之间的数字（不含结束）
- `开始..=结尾` 包含结尾
- `rev`方法可以反转Range

```rust
for number in (1..4).rev() {
    println!("{}！", number);
}
println!("点火！");
// 3！
// 2！
// 1！
// 点火！
```